#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <sstream>
#include <fstream>
#include <pthread.h>
#include <unistd.h>
#include <time.h>

using namespace std;

#define NUM_THREADS 2
#define FILENAME "rand_no"

struct blockParam
{
	const char *filename;
	double sum;
	int count;
	long long int start, end;
};

void *blockAvg(void *block);

/*
 *Initialization and division of work for each thread.
 *Combining the results generated by each thread
*/
double divideLabour(const char *filename)
{
	ifstream fpAvgFile(filename);
	if(!fpAvgFile)
	{
		cout<<"---ERROR: Could not open file named "<<filename<<"\n";
		exit(EXIT_FAILURE);
	}
	/*
	 * Now, check the size of the file so that work can be 
	 * equally divided (almost)
	 */
	fpAvgFile.seekg(0, ios::end);
	long long int length = fpAvgFile.tellg();
	fpAvgFile.close();
	
	long long int start[NUM_THREADS];
	long long int end[NUM_THREADS];
	
	start[0] = 0LL;
	end[NUM_THREADS - 1] = length;
	/*
	 * Assigning start and end locations for each thread and noting
	 * down the start and end positions in a couple of arrays
	 */
	
	for(int i=1; i < NUM_THREADS; i++)
		start[i] = (long long int)((length/NUM_THREADS)*i);
	for(int i=0; i < NUM_THREADS - 1; i++)
		end[i] = start[i+1];
	
	/*
	 * Initialize each block of file with appropriate parameters
	 */
	
	blockParam fileStruct[NUM_THREADS];
	for(int i = 0; i < NUM_THREADS; i++)
	{
		cout<<"Thread No. "<<i<<"\tStart: "<<start[i]<<"\tEnd: "<<end[i]<<"\n";
		fileStruct[i].filename = filename;
		fileStruct[i].sum = 0;
		fileStruct[i].count = 0;
		fileStruct[i].start = start[i];
		fileStruct[i].end = end[i];
	}
	
	/*
	 * Now, create threads, send the appropriate structure to the
	 * appropriate thread and then join them
	 */
	
	pthread_t readThread [NUM_THREADS];
	
	for (int i = 0; i < NUM_THREADS; i++)
		pthread_create(&readThread[i], NULL, blockAvg, (void *)&fileStruct[i]);
		
	for (int i = 0; i < NUM_THREADS; i++)
		pthread_join(readThread[i], NULL);

	double sum = 0.0;
	int count = 0;
	for (int i = 0; i < NUM_THREADS; i++)
	{
		sum += fileStruct[i].sum;
		count += fileStruct[i].count;
	}
	
	cout << "\nSum: " << sum << " Count: " << count << "\n";
	return (sum/count);
}

void *blockAvg(void *block)
{
	int readCounter = 0;
	blockParam *fileBlock = (blockParam*)block;
	
	string discardLine;
	ifstream fpAvgPart(fileBlock->filename);
	if(!fpAvgPart)
	{
	        cout<<"----ERROR: Could not open "<<fileBlock->filename<<" in thread\n";
		exit(EXIT_FAILURE);
	}
	
	/*Check if fileBlock is first block
	 * If yes, go to 1st location
	 * If not, then discard 1st line as its already included in the
	 * last block (last block read till newline)
	 */
	
	if(fileBlock->start == 0LL)
		fpAvgPart.seekg(0LL);
	else
	{
		fpAvgPart.seekg(fileBlock->start - 1); //-1 to ensure not on \n
		getline(fpAvgPart, discardLine);
		readCounter += discardLine.length(); //+1 for \n char, -1 for starting 1 to the left
	}
	/*
	 * Using char* instead of the standard string
	 * because it gives more control over detecting new line character
	 * and also because i know that new line does not remain on buffer
	 * after reading string. Thus use standard char*
	 */
	char number [15];
	while (fpAvgPart.getline(number, 14)) 
	{
		if (number[0] == '\0') 
		{
			readCounter++; // For discarded newline
			continue;
		}
		fileBlock->sum += atoi(number);
		fileBlock->count++;
		readCounter += strlen(number) + 1; // +1 for discarded newline
			
		if (readCounter + fileBlock->start >= fileBlock->end)
			break;
	}	
	
	pthread_exit(NULL);
}

/*
 * Main function has to be written here. 
 * The main function calls just the dividelabour function
 */
 
int main(int argc, char* argv[])
{
	char filename[256] = FILENAME;
	if(argc>=2)
		strcpy(filename, argv[1]);
	
	time_t start, end;
	double avg = 0;
	start = time(NULL);
	avg = divideLabour(filename);
	end = time(NULL);
	cout << "Time taken to read and compute average: " << difftime(end, start) <<"\n";

/*
 * Added precision and fixed to increase accuracy. Otherwise the average
 * always appears to be the same (since it is almost same) for a random
 * distribution of numbers
 */
	cout.precision(16);
	cout << "Avg: " << fixed << avg <<"\n";
	return 0;
}
